### **1060** 爱丁顿数

做这个题的时候，一开始把题目理解错了，以为要严格满足在X==E的情况下，必需有X天要超过E英里，但是如果以这个思路，如下的测试用例就没有答案：

```
5
1 2 3 4 5
```

> 在这个测试用例中，有5天超过0英里，4天超过1英里，3天超过2英里，2天超过3英里，1天超过4英里，如果强制满足X==E，那这样就没有答案了。

上面这个测试用例的答案应该为2，因为有2天是超过2英里的，但是在这组例子中，实际上有3天是超过2英里的，3>2是可以接受的。也就是说X>E是可以接受的。

这样排序后从后面往前找就行了，在上面的例子中，从后往前，5的时候说明有1天超过1英里，4说明有2天超过2英里，3的时候不能再说明有3天超过3英里了因为3==3了，程序返回上一个2英里。有`n`组测试用例，`i`从下标`n-1`的那个开始往前遍历，那`n-i`就可以表示成我们后面那个英里数。AC后的代码如下：

```c++
#include <algorithm>
#include <iostream>
#include <vector>

int main()
{
    int n;
    std::cin >> n;
    std::vector<int> nums(n);
    for (int i = 0; i < n; i++)
    {
        std::cin >> nums[i];
    }
    std::sort(nums.begin(), nums.end());
    if (nums[0] > n)
    {
        std::cout << n << std::endl;
        return 0;
    }
    for (int i = n - 1; i >= 0; i--)
    {
        if (n - i >= nums[i])
        {
            std::cout << n - i - 1 << std::endl;
            return 0;
        }
    }
    return 0;
}
```

> 此种算法还需注意一种情况，否则测试点3通不过，即如下的测试用例：
>
> ```
> 2
> 3 3
> ```
>
> 当序列中的最小的英里数都大于所给出的天数时，那么应该返回其天数，比如上面的测试用例正确的返回就应该是2。

